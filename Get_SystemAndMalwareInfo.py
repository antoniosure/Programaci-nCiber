import platform, subprocess, sys, os, hashlib
from datetime import datetime
try:
    # Intentar importar el módulo pefile
    import pefile
except ImportError:
    try:
        # Ejecutar pip para instalar el módulo
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pefile"])
        import pefile
    except subprocess.CalledProcessError as e:
        print(f"Error al instalar 'pefile': {e}")
        sys.exit(1)

try:
    # Intentar importar el módulo pandas
    import pandas
except ImportError:
    try:
        # Ejecutar pip para instalar el módulo
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pandas"])
        import pandas 
    except subprocess.CalledProcessError as e:
        print(f"Error al instalar 'pefile': {e}")
        sys.exit(1)        

try:
    # Intentar importar el módulo openpyxl
    from openpyxl import Workbook, load_workbook
    from openpyxl.utils import get_column_letter
except ImportError:
    try:
        # Ejecutar pip para instalar el módulo
        subprocess.check_call([sys.executable, "-m", "pip", "install", "openpyxl"])
        from openpyxl import Workbook, load_workbook
        from openpyxl.utils import get_column_letter
    except subprocess.CalledProcessError as e:
        print(f"Error al instalar 'openpyxl': {e}")
        sys.exit(1)

# Ruta del archivo Excel principal
excel_path = "Reporte_Sys_Mal_Inf.xlsx"  
csv_path = "reportes_sistema.csv"  # Archivo generado por el script PowerShell

# Obtener la ruta absoluta del directorio donde está el script
script_dir = os.path.dirname(os.path.abspath(__file__))

# Construir la ruta al archivo PowerShell dentro de la misma carpeta
ps_script_path = os.path.join(script_dir, "Get-SystemInfo.ps1")

# Función para cargar datos de CSV y añadirlos a un archivo Excel
def append_csv_to_excel(excel_file, csv_file, sheet_name="SystemReports"):
    # Leer el CSV generado por PowerShell
    if os.path.exists(csv_file):
        df_csv = pandas.read_csv(csv_file)

        # Verificar si el archivo Excel ya existe
        if os.path.exists(excel_file):
            # Cargar libro y hoja existente
            workbook = load_workbook(excel_file)
            if sheet_name not in workbook.sheetnames:
                workbook.create_sheet(sheet_name)
            sheet = workbook[sheet_name]
        else:
            # Crear un nuevo libro si no existe
            workbook = Workbook()
            sheet = workbook.active
            sheet.title = sheet_name
            # Crear encabezados
            sheet.append(["ReportName", "FileHash", "Date"])

        # Añadir datos a la hoja
        for row in df_csv.values:
            sheet.append(row.tolist())

        # Guardar cambios en el archivo Excel
        workbook.save(excel_file)
        print(f"Datos de {csv_file} añadidos a {excel_file} en la hoja '{sheet_name}'")
    else:
        print(f"No se encontró el archivo {csv_file}")

def log_report_to_excel(report_name, file_hash, report_date):
    """
    Registra los detalles del reporte (nombre, hash y fecha de creación) en un archivo Excel.
    
    Parámetros:
        report_name (str): Nombre del archivo de reporte.
        file_hash (str): Hash SHA-256 del archivo.
        report_date (str): Fecha de creación del reporte.
    """
    # Verificar si el archivo Excel ya existe
    if os.path.exists(excel_path):
        # Cargar el archivo Excel existente
        workbook = load_workbook(excel_path)
        sheet = workbook.active
    else:
        # Crear un nuevo archivo Excel con encabezados
        workbook = Workbook()
        sheet = workbook.active
        sheet.append(["Nombre del Reporte", "Hash del Archivo", "Fecha de Creación"])

    # Agregar una nueva fila con los datos del reporte
    sheet.append([report_name, file_hash, report_date])

    # Guardar el archivo Excel actualizado
    workbook.save(excel_path)

def save_report(content, report_type):
    """
    Guarda el contenido en un archivo y registra los detalles en el archivo Excel.

    Parámetros:
        content (str): Contenido a guardar en el archivo.
        report_type (str): Tipo de reporte para el nombre del archivo.
    """
    # Crear el nombre del archivo basado en la fecha y tipo de reporte
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    file_path = f"{report_type}_Report_{timestamp}.txt"
    
    # Guardar el contenido en el archivo
    with open(file_path, "w", encoding="utf-8") as file:
        file.write(content)

    # Calcular el hash SHA-256 del archivo
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256_hash.update(chunk)
    file_hash = sha256_hash.hexdigest()

    # Registrar el reporte en el archivo Excel
    report_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_report_to_excel(file_path, file_hash, report_date)

def check_suspicious_sections(pe):
    """
    Verifica si el archivo PE tiene secciones sospechosas.
    """
    suspicious_sections = []
    for section in pe.sections:
        if section.SizeOfRawData == 0:
            suspicious_sections.append(section.Name.decode('utf-8').strip())
    
    if suspicious_sections:
        return f"Secciones sospechosas encontradas: {suspicious_sections}"
    else:
        return "No se encontraron secciones sospechosas."

def analyze_pe(file_path):
    """
    Analiza un archivo PE y muestra información básica y posibles secciones sospechosas.
    """
    try:
        pe = pefile.PE(file_path)
        report_content = f"\nAnalizando: {file_path}\n"
        report_content += f"Entrypoint: {hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}\n"
        report_content += f"ImageBase: {hex(pe.OPTIONAL_HEADER.ImageBase)}\n"
        
        # Cálculo de hash MD5
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        file_hash = hash_md5.hexdigest()
        report_content += f"Hash MD5: {file_hash}\n"
        
        # Verificar secciones sospechosas
        report_content += check_suspicious_sections(pe) + "\n"
        
        return report_content  # Devolver el contenido en lugar de guardarlo directamente
        
    except Exception as e:
        print(f"Error analizando {file_path}: {e}")
        return f"Error analizando {file_path}: {e}\n"

def analyze_folder(folder_path):
    """
    Aplica el análisis PE a todos los archivos .exe de una carpeta.
    """
    report_content = ""
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            file_path = os.path.join(root, file)
            if file.endswith('.exe'):
                report_content += analyze_pe(file_path) + "\n"
    
    # Guardar el reporte final después de procesar toda la carpeta
    save_report(report_content, "PE_Folder_Analysis")

def get_folder_path():
    """
    Solicita al usuario la ruta de una carpeta y valida que exista.
    """
    while True:
        folder_path = input("Por favor, ingresa la ruta de la carpeta a analizar: ")
        if os.path.exists(folder_path) and os.path.isdir(folder_path):
            return folder_path
        else:
            print(f"La ruta '{folder_path}' no es válida. Inténtalo de nuevo.")

            
def check_and_install_powershell():
    """
    Verifica si PowerShell está instalado en Linux. Si no está instalado, intenta instalarlo.
    """
    try:
        result = subprocess.run(["pwsh", "-v"], capture_output=True, text=True)
        if result.returncode == 0:
            print("PowerShell ya está instalado en el sistema.")
        else:
            raise FileNotFoundError("PowerShell no está instalado.")
    except FileNotFoundError:
        print("PowerShell no está instalado. Procediendo con la instalación...")
        try:
            subprocess.run(["sudo", "apt", "update"], check=True)
            subprocess.run(["sudo", "apt", "install", "-y", "powershell"], check=True)
            print("PowerShell se ha instalado correctamente.")
        except subprocess.CalledProcessError as e:
            print(f"Error al instalar PowerShell: {e}")
            sys.exit(1)

def run_get_systeminfo():
    """
    Ejecuta el módulo Get-SystemInfo en el entorno actual.
    """
    try:
        # Ejecutar el script PowerShell con la ruta relativa
        subprocess.run(["powershell", "-ExecutionPolicy", "Bypass", "-File", ps_script_path], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error al ejecutar el script PowerShell: {e}")

def main():
    """
    Verifica el sistema operativo, instala PowerShell en Linux si es necesario,
    y ejecuta Get-SystemInfo directamente.
    """

    system = platform.system()
    print(f"Sistema operativo detectado: {system}")

    if system == "Linux":
        check_and_install_powershell()
    elif system != "Windows":
        print("Este programa solo está soportado en sistemas Windows y Linux.")
        sys.exit(1)

    #Muestra el menú al usuario y controla la ejecución.

    print("Análisis de Archivos PE y Recolección de información del sistema")
    
    while True:
        print("\n1) Ingresar ruta de carpeta para analizar si contiene Malware")
        print("2) Recolección de información del sistema (RAM, CPU, adaptadores de red, estadísticas de red y discos del sistema)")
        print("3) Salir")
        choice = input("Selecciona una opción (1, 2 o 3): ")

        if choice == '1':
            folder_path = get_folder_path()
            analyze_folder(folder_path)
        elif choice == '2':
            run_get_systeminfo()
            append_csv_to_excel(excel_path, csv_path)
        elif choice == '3':
            print("Saliendo del programa...")
            break
        else:
            print("Opción no válida. Inténtalo de nuevo.")


# No ejecutar main si se importa el módulo
if __name__ == "__main__":
    main()
